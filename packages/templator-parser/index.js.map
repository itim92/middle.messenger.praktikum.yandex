{"mappings":"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","sources":["packages/templator-parser/index.ts","packages/templator-parser/src/index.ts","packages/templator-parser/src/template-splitting/index.ts","packages/templator-parser/src/util/index.ts","packages/templator-parser/src/tokenizer/index.ts","packages/templator-parser/src/tokenizer/token-types.ts","packages/templator-parser/src/tree-generator/index.ts","packages/templator-parser/src/tree-generator/node-types.ts","packages/templator-parser/src/code-generator/index.ts"],"sourcesContent":["import { parse } from \"./src\";\n\nexport { parse };\n","import { parseTemplates } from \"./template-splitting\";\nimport Tokenizer from \"./tokenizer\";\nimport TreeGenerator from \"./tree-generator\";\nimport CodeGenerator from \"./code-generator\";\n\nexport function parse(raw: string) {\n    const [_code, templates] = parseTemplates(raw);\n    let code = _code;\n\n    for (const template of templates) {\n        const tokenizer = new Tokenizer(template);\n        const tokens = tokenizer.parse();\n\n        const treeGenerator = new TreeGenerator(tokens);\n        const tree = treeGenerator.generate();\n\n        const codeGenerator = new CodeGenerator(tree);\n        const templateCode = codeGenerator.generate();\n\n        code = code.replace(template.key ?? \"\", templateCode);\n    }\n\n    console.log(code);\n    return code;\n}\n\n/**\n * text node\n * start open tag\n * attribute name=\"\" or name={}\n * end open tag or end singled tag\n * closed tag\n */\n","import { isCloseOfPairTag } from \"../util\";\nimport { TemplateType } from \"../types/TemplateType\";\n\nexport function parseTemplates(code: string): [string, TemplateType[]] {\n    const templateRegexp = /<\\/?>/;\n\n    const templates = [];\n    let lastTemplate: TemplateType | undefined;\n    let offset = 0;\n    let matches;\n\n    while ((matches = code.slice(offset).match(templateRegexp))) {\n        if (!matches) {\n            break;\n        }\n\n        const tag = matches[0];\n        const isClose = isCloseOfPairTag(tag);\n        const matchIndex = matches.index ?? 0;\n\n        if (isClose && lastTemplate) {\n            lastTemplate.endIndex = offset + matchIndex;\n            lastTemplate.endIndexWithTag = offset + matchIndex + tag.length;\n\n            lastTemplate.code = code\n                .slice(lastTemplate.startIndexWithTag, lastTemplate.endIndex)\n                .trim();\n\n            lastTemplate.key = `{{{===${templates.length}===}}}`;\n            code =\n                code.slice(0, lastTemplate.startIndex) +\n                lastTemplate.key +\n                code.slice(lastTemplate.endIndexWithTag);\n            offset = 0;\n\n            continue;\n        }\n\n        lastTemplate = {\n            startIndex: offset + matchIndex,\n            startIndexWithTag: offset + matchIndex + tag.length,\n        };\n\n        templates.push(lastTemplate);\n        offset += matchIndex + tag.length;\n    }\n\n    return [code, templates];\n}\n","export function isTextNode(code: string) {\n    return /^([_\\n\\w\\d\\sа-я?!.,{}()[\\]'\"]+|{[_\\n\\w\\d\\sа-я?!.,{}()[\\]'\"]+}\\s+)</i.test(\n        code.trim()\n    );\n}\n\nexport function isOpenTag(code: string) {\n    return /^<[a-z]/i.test(code);\n}\n\nexport function isEndOfOpenTag(code: string) {\n    return /^\\/?>/.test(code);\n}\n\nexport function isCloseOfPairTag(code: string) {\n    return /^<\\//.test(code);\n}\n\nexport function isComponent(code: string) {\n    return /^<[A-Z]+/.test(code);\n}\n\nexport function isAttribute(code: string) {\n    return /^\\w+[\\w\\d-_]=/i.test(code);\n}\n\nexport function isTextNodeHasVars(code: string) {\n    return /{ ?[a-z._\\s\\d]+ ?}/i.test(code);\n}\n\nexport function isTextNodeHasLogic(code: string) {\n    return /^{ ?\\[?[`\"'a-z]/i.test(code);\n}\n","import {\n    isAttribute,\n    isCloseOfPairTag,\n    isEndOfOpenTag,\n    isOpenTag,\n    isTextNode,\n} from \"../util\";\nimport { TemplateType } from \"../types/TemplateType\";\nimport { TokenType } from \"../types/TokenType\";\nimport { OneOfTokenTypes, TOKEN_TYPES } from \"./token-types\";\n\nexport default class Tokenizer {\n    TOKEN_TYPES = TOKEN_TYPES;\n\n    private readonly tokens: TokenType[];\n    private template: TemplateType;\n    private code: string | undefined;\n\n    constructor(template: TemplateType) {\n        this.tokens = [];\n        this.template = template;\n        this.code = this.template.code;\n    }\n\n    parse() {\n        let code = this.code;\n        let lastToken: TokenType | undefined = undefined;\n\n        while (code) {\n            code = code.trim();\n            let token: TokenType | undefined = undefined;\n            if (isTextNode(code) && this.isMaybeNextText(lastToken)) {\n                [token, code] = this.parseTextNode(code);\n            } else if (isOpenTag(code)) {\n                [token, code] = this.parseOpenTag(code);\n            } else if (\n                isEndOfOpenTag(code) &&\n                this.isMaybeNextAttribute(lastToken)\n            ) {\n                [token, code] = this.parseEndOfOpenTag(code);\n            } else if (\n                isAttribute(code) &&\n                this.isMaybeNextAttribute(lastToken)\n            ) {\n                [token, code] = this.parseAttribute(code);\n            } else if (isCloseOfPairTag(code)) {\n                [token, code] = this.parseCloseTag(code);\n            }\n\n            if (typeof token !== \"undefined\") {\n                this.tokens.push(token);\n                lastToken = token;\n            } else {\n                console.log(this.tokens);\n                throw new Error(code);\n            }\n        }\n\n        this.code = code;\n\n        return this.tokens;\n    }\n\n    parseEndOfOpenTag(code: string): [TokenType, string] {\n        const re = /^(\\/?>)/;\n        const matches = code.match(re);\n\n        const token = this.createToken(this.TOKEN_TYPES.END_OF_TAG);\n\n        if (!matches) {\n            return [token, code];\n        }\n\n        const textNode = matches[1];\n\n        if (textNode.length) {\n            code = code.slice(textNode.length);\n            token.value = textNode;\n        }\n\n        if (/^\\/>/.test(textNode)) {\n            token.type = this.TOKEN_TYPES.END_OF_SINGLE_TAG;\n        }\n\n        return [token, code];\n    }\n\n    parseAttribute(code: string): [TokenType, string] {\n        const re =\n            /([\\w\\d]+=)(\"[\\w\\d_\\-=#{}().: ]+\"|{[\\w\\d_\\-=#().: \"']+})(\\s|\\/?)>?/i;\n        const matches = code.match(re);\n\n        const token = this.createToken(this.TOKEN_TYPES.ATTRIBUTE);\n\n        if (!matches) {\n            return [token, code];\n        }\n\n        const textNode = matches[1] + matches[2];\n\n        if (textNode.length) {\n            code = code.slice(textNode.length);\n            token.value = textNode;\n        }\n\n        return [token, code];\n    }\n\n    parseCloseTag(code: string): [TokenType, string] {\n        const re = /^(<\\/[a-z\\d]+>)/i;\n        const matches = code.match(re);\n\n        const token = this.createToken(this.TOKEN_TYPES.CLOSE_TAG);\n\n        if (!matches) {\n            return [token, code];\n        }\n\n        const textNode = matches[1];\n\n        if (textNode.length) {\n            code = code.slice(textNode.length);\n            token.value = textNode;\n        }\n\n        return [token, code];\n    }\n\n    parseOpenTag(code: string): [TokenType, string] {\n        const re = /^(<[a-z\\d]+)(\\s|>)/i;\n        const matches = code.match(re);\n\n        const token = this.createToken(this.TOKEN_TYPES.START_OF_TAG);\n\n        if (!matches) {\n            return [token, code];\n        }\n\n        const textNode = matches[1];\n\n        if (textNode.length) {\n            code = code.slice(textNode.length);\n            token.value = textNode;\n        }\n\n        return [token, code];\n    }\n\n    parseTextNode(code: string): [TokenType, string] {\n        const re =\n            /^([_\\n\\w\\d\\sа-я?!.,{}()[\\]'\"]+|{[_\\n\\w\\d\\sа-я?!.,{}()[\\]'\"]+}\\s+)</i;\n        const matches = code.match(re);\n\n        const token = this.createToken(this.TOKEN_TYPES.TEXT_NODE);\n\n        if (!matches) {\n            return [token, code];\n        }\n\n        const textNode = matches[1];\n\n        if (textNode.length) {\n            code = code.slice(textNode.length);\n            token.value = textNode.trim();\n        }\n\n        return [token, code];\n    }\n\n    createToken(type: OneOfTokenTypes): TokenType {\n        return { type, value: \"\" };\n    }\n\n    isMaybeNextAttribute(lastToken?: TokenType) {\n        switch (lastToken?.type) {\n            case this.TOKEN_TYPES.START_OF_TAG:\n            case this.TOKEN_TYPES.ATTRIBUTE:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    isMaybeNextText(lastToken?: TokenType) {\n        switch (lastToken?.type) {\n            case this.TOKEN_TYPES.CLOSE_TAG:\n            case this.TOKEN_TYPES.END_OF_SINGLE_TAG:\n            case this.TOKEN_TYPES.END_OF_TAG:\n                return true;\n            default:\n                return false;\n        }\n    }\n}\n","export const TOKEN_TYPES = {\n    START_OF_TAG: \"START_OF_TAG\",\n    END_OF_TAG: \"END_OF_TAG\",\n    END_OF_SINGLE_TAG: \"END_OF_SINGLE_TAG\",\n    CLOSE_TAG: \"CLOSE_TAG\",\n    ATTRIBUTE: \"ATTRIBUTE\",\n    TEXT_NODE: \"TEXT_NODE\",\n} as const;\n\nexport type OneOfTokenTypes = typeof TOKEN_TYPES[keyof typeof TOKEN_TYPES];\n","import { TOKEN_TYPES } from \"../tokenizer/token-types\";\nimport { isTextNodeHasLogic, isTextNodeHasVars } from \"../util\";\nimport { TokenType } from \"../types/TokenType\";\nimport { NODE_TYPE } from \"./node-types\";\nimport {\n    AttributeOfNodeType,\n    FragmentNodeType,\n    NodeType,\n    TagNodeType,\n    TextNodeType,\n} from \"../types/NodeType\";\n\nexport default class Tree {\n    private readonly tokens: TokenType[];\n\n    constructor(tokens: TokenType[]) {\n        this.tokens = tokens;\n    }\n\n    generate() {\n        const tree: NodeType[] = [];\n        const treeNode: TagNodeType = {\n            name: \"template\",\n            type: NODE_TYPE.TEMPLATE,\n            children: tree,\n            attributes: [],\n        };\n        const tagStack: TagNodeType[] = [];\n        // const meta = { lastNode: treeNode };\n\n        tagStack.push(treeNode);\n\n        for (const token of this.tokens) {\n            let node;\n            switch (token.type) {\n                case TOKEN_TYPES.TEXT_NODE:\n                    node = this.createTextNode(token);\n                    tagStack.at(-1)?.children.push(node);\n\n                    break;\n                case TOKEN_TYPES.ATTRIBUTE:\n                    node = this.createAttributeNode(token);\n                    tagStack.at(-1)?.attributes.push(node);\n\n                    break;\n                case TOKEN_TYPES.CLOSE_TAG:\n                    tagStack.pop();\n                    break;\n                case TOKEN_TYPES.END_OF_SINGLE_TAG:\n                    tagStack.pop();\n                    break;\n                case TOKEN_TYPES.END_OF_TAG:\n                    break;\n                case TOKEN_TYPES.START_OF_TAG:\n                    node = this.createTagNode(token);\n\n                    tagStack.at(-1)?.children.push(node);\n                    tagStack.push(node);\n                    break;\n                default:\n                    throw new Error(`invalid token ${token.type}`);\n            }\n\n            // meta.lastNode = node;\n        }\n\n        return treeNode;\n    }\n\n    createTagNode(token: TokenType): TagNodeType {\n        const tag = token.value.slice(1);\n        const type = /^[A-Z]/.test(tag)\n            ? NODE_TYPE.COMPONENT\n            : NODE_TYPE.HTML_ELEMENT;\n\n        return {\n            type,\n            name: tag,\n            attributes: [],\n            children: [],\n        };\n    }\n\n    createAttributeNode(token: TokenType): AttributeOfNodeType {\n        const [name, ...attrValueChunks] = token.value.split(\"=\");\n        const value = attrValueChunks.join(\"=\");\n\n        return {\n            name,\n            value,\n            smart: /^{/.test(value),\n        };\n    }\n\n    createTextNode(token: TokenType): TextNodeType | FragmentNodeType {\n        let value = token.value.trim();\n\n        if (isTextNodeHasVars(value)) {\n            value = value.replace(/({ ?[a-z._\\s\\d()]+ ?})/i, \"$$$1\");\n        } else if (isTextNodeHasLogic(value)) {\n            return this.createFragmentNode(token);\n        }\n\n        // console.log(value);\n        value = `\\`${value}\\``;\n\n        return {\n            type: NODE_TYPE.TEXT_NODE,\n            content: value,\n        };\n    }\n\n    createFragmentNode(token: TokenType): FragmentNodeType {\n        return {\n            type: NODE_TYPE.FRAGMENT,\n            content: `(() => ${token.value.trim().slice(1, -1)})()`,\n        };\n    }\n}\n","export const NODE_TYPE = {\n    TEMPLATE: \"TEMPLATE\",\n    FRAGMENT: \"FRAGMENT\",\n    TEXT_NODE: \"TEXT_NODE\",\n    HTML_ELEMENT: \"HTML_ELEMENT\",\n    COMPONENT: \"COMPONENT\",\n} as const;\n\nexport type OneOfNodeTypes = typeof NODE_TYPE[keyof typeof NODE_TYPE];\n","import { NODE_TYPE } from \"../tree-generator/node-types\";\nimport {\n    AttributeOfNodeType,\n    NodeType,\n    TagNodeType,\n    TextNodeType,\n} from \"../types/NodeType\";\n\nexport default class CodeGenerator {\n    private readonly tree: NodeType;\n\n    constructor(tree: NodeType) {\n        this.tree = tree;\n    }\n\n    generate() {\n        return this.generateNode(this.tree);\n    }\n\n    generateNodes(children: NodeType[]) {\n        const childrenCode: string[] = [];\n\n        for (const child of children) {\n            childrenCode.push(this.generateNode(child));\n        }\n\n        return `[${childrenCode.join(\",\\n\")}]`;\n    }\n\n    generateNode(node: NodeType): string {\n        let code;\n\n        switch (node.type) {\n            case NODE_TYPE.TEMPLATE:\n            case NODE_TYPE.COMPONENT:\n            case NODE_TYPE.HTML_ELEMENT:\n                code = this.generateElement(node);\n                break;\n            case NODE_TYPE.TEXT_NODE:\n                code = this.createTextElement(node);\n                break;\n            case NODE_TYPE.FRAGMENT:\n                code = this.createElement({\n                    element: \"'template'\",\n                    attributes: \"null\",\n                    children: node.content,\n                });\n                break;\n            default:\n                throw Error(`unknown node.type ${node}`);\n        }\n\n        return code;\n    }\n\n    generateElement(node: TagNodeType) {\n        const element =\n            NODE_TYPE.COMPONENT === node.type ? node.name : `\"${node.name}\"`;\n        const attributes = this.createAttributes(node.attributes);\n        const children = node.children\n            ? this.generateNodes(node.children)\n            : `null`;\n\n        return this.createElement({\n            element,\n            attributes: attributes ?? \"null\",\n            children,\n        });\n    }\n\n    createAttributes(attributes: AttributeOfNodeType[]) {\n        if (!attributes || !attributes.length) {\n            return null;\n        }\n\n        const code = [];\n        for (const attr of attributes) {\n            const value = attr.smart ? attr.value.slice(1, -1) : attr.value;\n\n            code.push(`${attr.name}: ${value}`);\n        }\n\n        return `\n    {\n       ${code.join(\",\\n\")}\n    }`;\n    }\n\n    createTextElement(node: TextNodeType) {\n        return `document.createTextNode(${node.content})`;\n    }\n\n    createElement({\n        element,\n        attributes,\n        children,\n    }: {\n        element: string;\n        attributes: string;\n        children: string;\n    }) {\n        return `\n    Templator.createElement(\n        ${element}, \n        ${attributes}, \n        ${children}\n    )`;\n    }\n}\n"],"names":[],"version":3,"file":"index.js.map"}